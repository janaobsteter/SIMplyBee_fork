---
title: "Honeybee biology"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Honeybee biology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  markdown:
    wrap: 80
    canonical: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE
)
```

# Introduction

This vignette introduces SIMplyBee package by describing and demonstrating how
SIMplyBee implements honeybee biology. Specifically, it describes:

1.  initiating simulation with founder genomes and simulation parameters,

2.  creating and building up a colony,

3.  colony structure,

4.  complementary sex determining (*CSD*) locus.

First, you need to install the package with
`install.packages(pkg = "SIMplyBee")`.

Now load the package and dive in! You load the package by running

```{r}
library(package = "SIMplyBee")
```

# Initiating simulation with founder genomes and global parameters

Figure 1 visualizes the initiation of the simulation. First, we need to simulate
some genomes that represent the founder population. You can quickly generate
random genomes using AlphaSimR's `quickHaplo()`. These founder genomes are
rapidly simulated by randomly sampling 0s and 1s, and do not include any
species-specific demographic history. This is equivalent to having all loci with
allele frequency 0.5 and being in linkage equilibrium. This method is only used
when you want to generate "something", in other words a number of non specific
genomes.

Alternatively, you can simulate an accurate honeybee genome by use SIMplyBee's
`simulateHoneybeeGenomes()`. `simulateHoneybeeGenomes()` simulates the honeybee
genome using MaCS (Chen et al., 2009) and is currently allowing for the
simulation of three subspecies: *A. m. ligustica*, *A. m. carnica*, and *A. m.
mellifera* according to the demographic model published in Wallberg et al.,
2014.

As a first demonstration, we will use `quickHaplo()` and simulate random genomes
of two founding individuals. In this example, the genomes will be represented by
only three chromosomes and 1000 segregating sites per chromosome. Honeybees have
16 chromosomes and far more segregating sites per chromosome, but we want a
quick simulation here.

```{r founder genomes}
founderGenomes <- quickHaplo(nInd = 2, nChr = 3, segSites = 100)
```

Alternatively, we will use SIMplyBee's `simulateHoneybeeGenomes()` to create a
founder population including the genomes of 4 *A. m. mellifera* (North)
individuals and 2 *A. m. carnica* individuals. The genomes will be represented
by only three chromosomes and 5 segregating sites per chromosome. These numbers
are of course extremely low but for demonstrative reasons we want a quick
example. This chunk of code should take a few minutes to run.

```{r simulate honeybee genomes}
founderGenomes2 <- simulateHoneyBeeGenomes(nMelN = 4,
                                           nCar = 2,
                                           nChr = 3,
                                           nSegSites = 5)
```

Unfortunately, due to the complexity of this function, even using such small
numbers requires a lot of computing power and takes a while to run. Simulating a
group of founder genomes with more realistic numbers will therefore require a
lot of time to run. We suggest outsourcing this process to an external server
and to save the outcome as an Rdata file. This Rdata file is easy to load into
your environment and work with.

```{r save Rdata file}
save(founderGenomes2, file="FounderGenomes2_3chr.RData")
```

Besides specifying the number of individuals, chromosomes, and segregating
sites, `simulateHoneybeeGenomes()`, also takes a number of genomic parameters:
effective population size, ploidy, number of base pairs in a chromosome, genetic
length of a chromosome, mutation rate, and recombination rate. The default
values for these numbers follow published references, hence we do not recommend
changing them, although you can. Also, the effective population size refers to
the Wallberg demographic model (Wallberg et al., 2014) that is internally used
for simulating the honeybee demography. Thus, this value cannot be changed
safely and would not recommend its change.

```{r deeper looking to the arguments}
??simulateHoneybeeGenomes
```

Now we are ready to setup global simulation parameters using `SimParamBee`.
`SimParamBee` builds upon AlphaSimR's `SimParam`, which includes genome and
trait parameters, but also global pedigree and recombination events.
`SimParamBee` additionally holds honeybee specific simulation information
(Figure 1):

-   default number of workers (`SP$nWorkers`) and drones (`SP$nDrones`) in a
    full-sized colony; these numbers are used by functions such as
    `createWorkers/Drones()`, `addWorkers/Drones()` and `buildUp()`;
-   default number of drones that a virgin queen mates with (`SP$nFathers`)
-   the *CSD* information: the chromosome of the *CSD* (`SP$csdChr`), the
    position (`SP$csdPos`), and the desired number of *CSD* alleles in a
    population (`SP$nCsdAlleles`) or the length of the *CSD* locus
    (`SP$nCsdSites`). Number of *CSD* alleles and the length of the locus are
    co-determined, since `nCsdAlleles = nCsdSites**2`. By default, the *CSD* is
    placed on its real genomic position on chromosome 3. However, if the user
    simulates less than three chromosomes, the *CSD* is placed on chromosome 1;
-   pedigree for each individual created in the simulation (`SP$pedigree`)
-   caste information for each individual created in the simulation (`SP$caste`)

You can read more about the `SimParam` and `SimParamBee` in the help pages
(`help(SimParamBee)` and `help(SimParam)`). Here we will point out that we
recommend saving this object with the name `SP`. Namely, all SIMplyBee functions
will use this object if you don't directly specify `simParamBee` argument. The
*CSD* properties have to be set at the creation of the `SimParamBee`, while
other defaults can be set subsequently.

```{r SimParamBee}
SP <- SimParamBee$new(founderGenomes, nCsdAlleles = 32)
SP$nWorkers <- 100
SP$nDrones <- 10
```

After creating the `SimParamBee` object, you can inspect it! This returns a lot
of output and we suggest you return back to this point once you are comfortable
with the basic functionality!

```{r SP, eval = FALSE}
show(SP)
```

```{r initialization_diagram, echo=FALSE, out.width='100%', fig.cap = "Simulation initiation."}
knitr::include_graphics("../man/figures/founderpop.png")
```

From the simulated founder genomes, we first need to create virgin queens
(Figure 1). These will serve as our our first honeybee individuals (so called
base population). In AlphaSimR and SIMplyBee, individuals are stored in so
called `Pop` class, that holds a group of individuals with their individual
identification, parent identifications, as well as genomes and trait values. So,
the `basePop` is a population (`Pop` class object) of two individuals, our
virgin queens. If we call our `basePop`, we see some basic information about our
population: the ploidy, number of individuals, chromosome, loci, and traits. We
next check whether our individuals are of certain caste with `is*()` functions,
where `*` can be either `queen`, `worker`, `drone`, `virginQueen`, or `father`.
These functions return `TRUE` if the individual is a member of the caste in
question and `FALSE` is it is not. These functions check the caste information
in the `SP$caste`. Here, we use `isVirginQueen()` to check whether our base
population is all virgin queens.

```{r base pop virgin queens}
baseQueens <- createVirginQueens(founderGenomes)
baseQueens
isVirginQueen(baseQueens)
```

Similarly, you can use the function `getCaste()` to get the caste of each
individual - we discuss this function below.

We will use the first virgin queen to create five drones for future mating.
Technically, virgin queens do not create drones. Only queens with colonies
create drones. However, to get the simulation up and running, we need drones and
the function `createDrones()` can work both with virgin queens or colonies (we
will talk about colonies in the next section). You can use more than one virgin
queen to create the drones or even an entire drone congregation area (DCA) with
as many drones per virgin queen as you want (`nInd`).

```{r base pop drones}
baseDrones <- createDrones(x = baseQueens[1], nInd = 15)
baseDrones
```

# Creating and building up a colony

We will use the other virgin queen to create a colony. Again, you can use more
than one virgin queen to create more than one colony. In SIMplyBee, a honeybee
colony is stored in object of `Colony` class. You can create a new colony with
the function `createColony()`: you can create a completely empty colony or a
colony with either a virgin or a mated queen. The `Colony` class contains all
its members in five castes: `queen`, `workers`, `drones`, `virginQueens`, and
`fathers`. The `Colony` further contains technical information about the colony,
its identification `id` and `location` coded as (`latitude`, `longitude`)
coordinates. Further, it contains logical information about the past colony
events: `split`, `swarm`, `supersedure`, or `collapse`. It also contains
`production` status, which indicates whether we can collect a production
phenotype from the colony. The latter is possible when the colony is built-up to
its full size and has not swarmed. The production is turned off when a colony
downsizes, collapses, and swarms, and for the split of a split colony. You will
learn about these colony events in `Colony_events` vignette.

```{r colony}
colony <- createColony(x = baseQueens[2])
colony
```

We see all the above mentioned information also in the printout of the `Colony`
object. For this specific colony, we see that the ID of the colony is "8", the
location is not set, and there is no queen (hence `NA`). There are consequently
not fathers in the colony, nor any workers, drones or virgin queens. All the
events are set to `FALSE` (you will learn more about events in the Colony events
vignette) and the colony is not productive, since it does not include any
individuals.

Let's now mate our virgin queen, so that she becomes a queen and can start
laying eggs for her own workers and drones.

```{r cross colony}
colony <- cross(colony, drones = baseDrones)
colony
```

We see that the virgin queen was upgraded to a queen - hence we have a queen
with the ID "2" and no virgin queens in our colony.

Next, Next, let's build up our colony by using the function `buildUp()` that
adds in workers and drones. This function takes parameters `nWorkers` and
`nDrones`, where we specify how many workers and drones to add. However, it
these numbers are not specified in the function's call, the function uses the
default numbers from the `SimParamBee` object (`SP$nWorkers` and `SP$nDrones`).
This function also always turns the `production` status to `TRUE`, since it
assumes we are building the colony up to its full-size.

```{r build up colony}
buildUp(colony, nWorkers = 10, nDrones = 7)
buildUp(colony)
```

All the functions in SIMplyBee return objects, hence we need to save them to
something, otherwise they are lost.

```{r}
colony <- buildUp(colony)
colony
```

# Colony structure

Lets explore our colony. In every colony we have different groups of individuals
(castes). These include: queen, fathers, workers, drones, and virgin queens. The
queen controls the colony, workers do all the hard work, drones disseminate
queen's genes, and one of the virgin queens will eventually replace the queen.
We also store fathers, which represent drones that the queen mated with
(basically the sperm stored in her spermatheca). Storing fathers enables us to
generate colony members on demand. SIMplyBee contains `n*()` functions that
allow us to count the number of individuals in each caste, where `*` is `queen`,
`fathers`, `workers`, `drones`, and `virginQueens`. Let's count how many
individuals we have for each caste in our colony.

```{r colony numbers 1}
nQueens(colony)
```

```{r colony numbers 2}
nFathers(colony)
```

```{r colony numbers 3}
nWorkers(colony)
```

```{r colony numbers 4}
nDrones(colony)
```

```{r colony numbers 5}
nVirginQueens(colony)
```

Next, we can access the individuals of each caste with `get*()` functions. These
functions leave the colony and its members intact (do not change the colony),
but make a copy of the individuals instead.

```{r colony castes via get 1}
(queen <- getQueen(colony))
```

```{r colony castes via get 2}
(fathers <- getFathers(colony))
```

```{r colony castes via get 3}
(workers <- getWorkers(colony))
```

```{r colony castes via get 4}
(drones <- getDrones(colony))
```

```{r colony castes via get 5}
(virginQueens <- getVirginQueens(colony))
```

As you see above, there are no virgin queens present in the colony at this
moment, since the queen is active. Future colony events will change this.

Should you want to pull out, that is, remove castes or their members, have a
look at `pull*()` functions. These functions return a list of objects: `pulled`
being the pulled inviduals (`Pop` object), and `remnant` being the remaining
colony without the pulled individuals.

```{r}
tmp <- pullWorkers(colony, n = 10)
colony <- tmp$remnant
colony
```

```{r}
pulledWorkers <- tmp$pulled
pulledWorkers
```

Next, you can obtain the caste of each individual with the `getCaste()`
function. As already mentioned above, a similar group of functions is the
`is*()` functions that check whether an individual is of specific caste. Let's
now obtain the caste of colony members:

```{r caste queen}
getCaste(queen)
```

```{r caste fathers}
getCaste(fathers)
```

and so on. When you have a bunch of bees at hand and you might not know their
source, the `getCaste()` can be very useful.

```{r caste bees}
bees <- c(queen, fathers[1:2], workers[1:2], drones[1:2])
getCaste(bees)
```

# Complementary sex determining locus

The complementary sex determiner (*CSD*) locus, well, complements sex
determination. Fertilised eggs that are heterozygous at the *CSD* locus develop
into workers. On the other hand, homozygous eggs develop into unviable drones.
These drones are usually discarded by workers. SIMplyBee does not store these
unviable drones, but it does store their number in the queen's miscellanious
slot (`queen@misc`). Here, you can find the total number of workers and drones
produced by the queen (`nWorkers` and `nDrones`) and how many of the diploid
offspring were homozygous at the *CSD* (`nHomBrood`). There is also a
`pHomBrood` slot, that represents the theoretical proportion of offspring that
are expected to be homozygous based on queen's and father's *CSD* alleles. You
can obtain `pHomBrood` and `nHomBrood` values with the corresponding
`pHomBrood()` and `nHombrood()` functions that can be applied either on the
queen (`Pop` class) or colony (`Colony` class) directly. You can obtain the
entire `misc` slot with the `getMisc()` function.

```{r}
getMisc(getQueen(colony))
```

Technically, SIMplyBee represents the *CSD* locus as a series of bi-allelic
single nucleotide polymorphisms that don't recombine. So, the *CSD* locus is
represented as a haplotype and different haplotypes represent different *CSD*
alleles. By varying the number of sites within the *CSD* locus we can control he
number of distinct alleles (see `help(SimParamBee)`).

We can retrieve information about *CSD* variation with `getCsdAlleles()`. For
details on where the *CSD* locus is and the number of distinct alleles, see
`help(SimParamBee)`. The first row of the output shows marker identifications
(chromosome_locus) and the first column shows haplotype identifications
(individual_haplotype). The alleles are represented with a sequence of 0's and
1's. You can see that the two sequences are different, meaning that she is
heterozygous, as expected.

```{r csd}
getCsdAlleles(queen)
```

A keen geneticist would immediately inspect *CSD* alleles of fathers to check
for any similarity with the queen's *CSD* alleles. Let's boost a chance of such
an event by creating an inbreed colony. We will create a virgin queen from the
current colony and mate her with her brothers. Oh, dear me.

```{r inbred colony}
inbredColony <- createColony(x = createVirginQueens(x = colony, nInd = 1))
fathers <- selectInd(drones, nInd = SP$nFathers, use = "rand")
inbredColony <- cross(inbredColony, drones = fathers)
getCsdAlleles(inbredColony)
getCsdAlleles(inbredColony, unique = TRUE)
```

Can you spot any matches? Let's calculate the expected proportion of homozygous
brood from this mating.

```{r pHomBrood}
pHomBrood(inbredColony)
```

Let's see how many homozygotes will we observe. Note that inheritance is a
random process, so a realised number of homozygotes will deviate from the
expected proportion.

```{r hHomBrood}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

We tried adding 100 workers, but we only got `r nWorkers(inbredColony)`. The
difference of `r nHomBrood(inbredColony)` is due to *CSD* homozygous brood.
Let's add another set of workers to show variation in the realised numbers and
accumulation of information.

```{r hHomBrood II}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

In total we tried adding 200 workers. We got `r nWorkers(inbredColony)` workers
and `r nHomBrood(inbredColony)` homozygous brood. To see all this information,
we can inspect the miscellaneous slot of the queen that contains the fathers
population as well as the cumulative number of workers, drones, homozygous
brood, and the expected proportion of homozygous brood.

```{r queens counters}
getMisc(getQueen(inbredColony))
```

References: Wallberg, A., Han, F., Wellhagen, G. et al. A worldwide survey of
genome sequence variation provides insight into the evolutionary history of the
honeybee Apis mellifera. Nat Genet 46, 1081--1088 (2014).
<https://doi.org/10.1038/ng.3077>
