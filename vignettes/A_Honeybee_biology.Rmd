---
title: "SIMplyBee - Honeybee biology"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SIMplyBee - Honeybee biology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  include = TRUE
)
```

# Introduction

This vignette introduces SIMplyBee package by describing and demonstrating how SIMplyBee implements honeybee biology. Specifically, it describes:

1.  Initiating simulation with founder genomes and simulation parameters,

2.  Creating and building up a colony,

3.  Colony structure,

4.  Complementary sex determining (csd) locus

Now load the package and dive in!

```{r load package}
library(package = "SIMplyBee")
```

TODO: Say something about the image (covering 1-4) and how you can use it as a guide?

TODO: add colony creation image - not working yet \# knitr::include_graphics("\~/Desktop/GitHub/SIMplyBee/SIMplyBee/vignettes/images/founderpop_diagram2.pdf", auto_pdf = getOption("knitr.graphics.auto_pdf",FALSE))

# Initiating simulation with founder genomes and global parameters,

We simulate some genomes that represent the founder population. You can quickly generate random genomes using AlphaSimR's `quickHaplo()`. These founder genomes are rapidly simulated by randomly sampling 0s and 1s, and does not include any species specific demographic history. This is equivalent to having all loci with allele frequency 0.5 and being in linkage equilibrium. This method is only used when you want to geneterate "something", in other words a non specific group of genomes.

Alternatively, you can simulate an accurate honeybee genome by use SIMplyBee's `simulateHoneybeeGenomes()`. `simulateHoneybeeGenomes()` simulates the honeybee genome using MaCS (ref) and is currently allowing for the simulation of three subspecies: A. m. ligustica, A. m. carnica, and A. m. mellifera according to the demographic model published in Wallberg et al., 2014.

As a first demonstration, we will use `quickHaplo()` and simulate random genomes of two founding individuals. In this example, the genomes will be represented by only three chromosomes and 1000 segregating sites per chromosome. Honeybees have 16 chromosomes and far more segregating sites per chromosome, but we want a quick simulation here.

```{r founder genomes}
founderGenomes <- quickHaplo(nInd = 2, nChr = 3, segSites = 100)
```

Alternatively as a second demonstration, using SIMplyBee's `simulateHoneybeeGenomes()`, we will create a founder population containing the genomes of 4 A.m.mellifera (North) individuals and 2 A.m.carnica individuals. The genomes will be represented by only three chromosomes and 5 segregating sites per chromosome in this example. These numbers are of course extremely low but for demonstrative reasons we want a quick example. This chunk of code should take a few minutes to run.

```{r simulate honeybee genomes}
founderGenomes2 <- simulateHoneyBeeGenomes(nMelN = 4,
                                          nCar = 2,
                                          nChr = 3,
                                          nSegSites = 5)
```

Unfortunately, due to complexity of this function, even using such small numbers requires a lot of computing power and takes a while to run. Simulating a group of founder genomes with more realistic numbers will therefore require a lot of time to run. We suggest outsourcing this process to an external server and to save the outcome as an Rdata file. This Rdata file is easy to load into your environment and work with.

```{r save Rdata file}
save(founderGenomes2, file="FounderGenomes2_3chr.RData")
```

There are many arguments provided by `simulateHoneybeeGenomes()`, which are listed below. However, we will not be going into depth describing them in this article.

```{r simulateHoneybeeGenomes arguments}
nMelN = 0L,
nMelS = 0L,
nCar = 0L,
nLig = 0L,
Ne = 170000L, # Wallberg 2014 
ploidy = 2L,
nChr = 16L,
nSegSites = 100L,
nBp = 2.252e+8 / 16, # GenBank Amel_Hv3.1
genLen = 3.199121, # Beye et al., 2006
mutRate = 3.4e-9, # Yang et al. (2015)
recRate = 2.3e-7, # Beye et al., 2006
nThreads = NULL) 
```

Most arguments have a provided default values, most of which currently correspond to the Wallberg demographic model (Wallberg 2014). Unfortunately, these values cannot be changed safely and would not recommend their change, as they correspond to a this model specifically. If you do wish to make a personalised founder population genome, keep in mind that they won't correspond to the model and may lead to problems. 

```{r deeper looking to the arguments}
??simulateHoneybeeGenomes
```

Now we are ready to setup global simulation parameters using `SimParamBee`. `SimParamBee` enables the user to tweak many simulation settings, which you can read about in the help pages (`help(SimParamBee)` and `help(SimParam)`). Here we will point out that we recommend saving this object with the name `SP`. Namely, all SIMplyBee functions will use this object, if you don't directly specify `simParamBee` argument.

```{r SimParamBee}
SP <- SimParamBee$new(founderGenomes)
```

There are many options provided by `SimParamBee` of which we will not talk about now. You can quickly take a peek into the information and functions stored in the `SP` object. The following code gives a lot of output and we suggest you return back to this point once you are comfortable with the basic functionality! We would recommend familarising yourself with some of the more important parameters, such as `SP$nWorkers` which generates the number of workers you want in the colony and is used in functions such as `createWorkers()`, `addWorkers()` and `buildUp()`. The equivalent parameters can be found for other caste members. The `SP` also stores the csd information, such as its location, which you can spcify using `SP$csdPosStart` and `SP$csdPosStop`.

```{r SP, eval = FALSE}
show(SP)
```

There are many options provided by `SimParamBee` of which we will not talk about now. You can quickly take a peek into the information and functions stored in the `SP` object. The following code gives a lot of output and we suggest you return back to this point once you are comfortable with the basic functionality!

```{r SP, eval = FALSE}
show(SP)
```

From the simulated genomes, we will create virgin queens. These will serve as our our first honeybee individuals. In SIMplyBee, we use AlphaSimR's populations (`Pop` class). So, the `basePop` is a population of two individuals, our virgin queens.

```{r base pop virgin queens}
baseQueens <- createVirginQueens(founderGenomes)
baseQueens
isVirginQueen(baseQueens)
```

We will use the first virgin queen to create five drones for mating. Technically, virgin queens do not create drones. Only queens with colonies create drones. However, to get the simulation up and running, we need drones and the function `createDrones()` can work both with virgin queens or colonies (we will talk about colonies in the next section).

```{r base pop drones}
baseDrones <- createDrones(x = baseQueens[1], nInd = 15)
baseDrones
```

A keen reader will notice that drones' ploidy is two. We will address this in the next sections.

# Creating and building up a colony

We will use the other virgin queen to create a colony. In SIMplyBee, a colony is an object of `Colony` class with all sorts of information.

```{r colony}
colony <- createColony(x = baseQueens[2])
colony
```

Before we look into the colony, lets mate the virgin queen, so that she becomes a queen and can start laying eggs for her own workers and drones.

```{r cross colony}
colony <- cross(colony, drones = baseDrones)
colony
```

We build up colony with workers and drones using `buildUpColony()`.

```{r build up colony}
buildUp(colony, nWorkers = 10, nDrones = 7)
```

Of note, we have not saved the result of the `buildUpColony()` call, so our currently saved colony object `colony` still doesn't contain workers and drones.

At this point, its worth mentioning that `SimParamBee` (saved as the `SP` object) conveniently holds some defaults for the number of workers and drones. The defaults are just some numbers to work with. You should adapt these defaults to your needs.

```{r SP n values}
SP$nWorkers
```

```{r SP n values 2}
SP$nDrones
```

When we run SIMplyBee functions, such defaults are automatically used. We show this now by calling the `buildUp()` function on our colony. Note that now we are saving the function output and rewriting the currently saved colony object.

```{r build up colony with defaults}
colony <- buildUp(colony)
colony
```

# Colony structure

Lets explore this colony. In every colony we have different groups of individuals (castes). These include: queen, fathers, workers, drones, and virgin queens. The queen controls the colony, workers do all the hard work, drones disseminate queen's genes, and one of the virgin queens will eventually replace the queen. We also store fathers, which represent drones that the queen mated with. Storing fathers enables us to generate colony members on demand. Let's count how many individuals we have for each caste.

```{r colony numbers 1}
nQueens(colony)
```

```{r colony numbers 2}
nFathers(colony)
```

```{r colony numbers 3}
nWorkers(colony)
```

```{r colony numbers 4}
nDrones(colony)
```

```{r colony numbers 5}
nVirginQueens(colony)
```

We can also access castes using `get*()` functions.

```{r colony castes via get 1}
(queen <- getQueen(colony))
```

```{r colony castes via get 2}
(fathers <- getFathers(colony))
```

```{r colony castes via get 3}
(workers <- getWorkers(colony))
```

```{r colony castes via get 4}
(drones <- getDrones(colony))
```

```{r colony castes via get 5}
(virginQueens <- getVirginQueens(colony))
```

As you see above, there are no virgin queens present in the colony at this moment, since the queen is active. Future colony events will change this.

Should you want to pull out, that is, remove castes, or their members, have a look at `pull*()` functions.

There is additional information that you can retrieve. Peek under the hood and view the complete colony data structure with `str(colony)`. This gives a lot of output and we suggest you return back to this point once you are comfortable with the basic functionality!

```{r colony structure, eval = FALSE}
str(colony)
```

To explore the various accessor or modification functions, study the SIMplyBee's index of functions.

```{r help, eval = FALSE}
help(SIMplyBee)
```

The caste information of colony members is as you would expect:

```{r caste queen}
getCaste(queen)
```

```{r caste fathers}
getCaste(fathers)
```

and so on. When you have a bunch of bees at hand and you might not know their source, the `getCaste()` can be very useful.

```{r caste bees}
bees <- c(queen, fathers[1:2], workers[1:2], drones[1:2])
getCaste(bees)
```

# Complementary sex determining locus

TODO: add genome image (tree and inheritance and csd)?

The complementary sex determining (CSD) locus, well, complements sex determination. Fertilised eggs that are heterozygous at the csd locus develop into workers. On the other hand, homozygous eggs develop into unviable drones. These drones are usually discarded by workers. SIMplyBee doesn't store these unviable drones, but it does store their number in the `SP`. 

We can retrieve information about csd variation with `getCsdAlleles()`. For details on where the csd locus is and the number of distinct alleles, see `help(SimParamBee)`. The output below shows two sequences (in two rows) of 0s and 1s representing respectively ancestral and mutation alleles along the csd locus for the queen. You can see that the two sequences are different, meaning that she is heterozygous, as expected.

```{r csd}
getCsdAlleles(queen)
```

Technically, SIMplyBee represents the csd locus as a series of bi-allelic single nucleotide polymorphisms that don't recombine. So, the csd locus is represented as a haplotype and different haplotypes represent different csd alleles. By varying the number of sites within the csd locus we can control the number of distinct alleles (see `help(SimParamBee)`).

A keen geneticist would immediately inspect csd alleles of fathers to check for any similarity with the queen's csd alleles. Lets boost a chance of such an event by creating an inbreed colony. We will create a virgin queen from the current colony and mate her with her brothers. Oh, dear me.

```{r inbred colony}
inbredColony <- createColony(x = createVirginQueens(x = colony, nInd = 1))
fathers <- selectInd(drones, nInd = SP$nFathers, use = "rand")
inbredColony <- cross(inbredColony, drones = fathers)
getCsdAlleles(inbredColony)
getCsdAlleles(inbredColony, unique = TRUE)
```

Can you spot any matches? Let's calculate the expected proportion of homozygous brood from this mating.

```{r pHomBrood}
pHomBrood(inbredColony)
```

Let's see how many homozygotes will we observe. Note that inheritance is a random process, so a realised number of homozygotes will deviate from the expected proportion.

```{r hHomBrood}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

We tried adding 100 workers, but we only got `r nWorkers(inbredColony)`. The difference of `r nHomBrood(inbredColony)` is due to csd homozygous brood. Let's add another set of workers to show variation in realised numbers and accumulation of information.

```{r hHomBrood II}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

In total we tried adding 200 workers. We got `r nWorkers(inbredColony)` workers and `r nHomBrood(inbredColony)` homozygous brood. To see all this information, we can inspect the miscellaneous slot of the queen that contains the fathers population as well as the cumulative number of workers, drones, homozygous brood, and the expected proportion of homozygous brood.

```{r queens counters}
getMisc(getQueen(inbredColony))
```
